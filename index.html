<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
Auto Round
</title>
<script src="geometry.js?1"></script>
<script src="libColor.js"></script>
</head>
<body style="margin:0px">
<canvas id="cv" width=600 height=500 style="background:black;border:solid 1px red; /*transform:scale(1,-1)*/"></canvas>
<script>

if (String(location).indexOf("jhepneige.github.io")>-1) document.title+=" online";

/// Augments
if (!Array.prototype.remove) Object.defineProperty(Array.prototype,"remove",{value(arg){ this.splice(this.indexOf(arg),1); }});
var flo=Math.floor, ran=Math.random, pi=Math.PI,sqrt=Math.sqrt;
var cos=Math.cos,sin=Math.sin;
function hexByte(x){return x.toString(16).padStart(2,"0") ;}

/// HMI
var cv=document.getElementById("cv");
var ctx=cv.getContext("2d");
var w=cv.width, h=cv.height;
document.getElementById("cv").addEventListener("mouseup", e=>{
	shout();
});
function shout(msg="MOTHEATER") {
	var el=document.createElement("div");
	el.textContent=msg;
	el.style="position:relative;color:black";
	document.body.append(el);
	setTimeout(()=>{document.body.removeChild(el);}, 3000);
}


/// Resources

// var obstacle={r:50,x:175,y:200};
// var wanderer={r:20,x:35,y:30};

var rounds=[];
var points=[];

/// Brain

//TODO: stuff hardcoded right and left
const frameDur=0.010; ///second
const clearance=0.1;
async function robot(){
	var side=flo( 4*ran() );

	var wanderer={
		r:15+10*ran()
		,x: (side & 1 ? w/2+(ran()-0.5)*250     : (side > 1 ? w-25 : 25 ) )
		,y: (side & 1 ? (side > 1 ? h-25 : 25 ) : h/2+(ran()-0.5)*200 )
		,vec:[0,0]
		,type:side
	};
	wanderer.stack=[];
	var dest={pos:[
		 side & 1 ? wanderer.x              : (side > 1 ? 25 : w-25 )
		,side & 1 ? (side > 1 ? 25 : h-25 ) : wanderer.y
	]};
	wanderer.dest=dest;
	rounds.push(wanderer);
	var speed;
	wanderer.step=0;
	function getSpeed(){return 60*(1+0.5*ran()); } /// speed in pixel per second
	function upPath(){
		wanderer.vec=mult(normed(dif(dest.pos,wanderer)),frameDur*speed);
		wanderer.step=flo(dist(dest.pos,wanderer)/(frameDur*speed));
	}
	wanderer.upPath=upPath;
	// dest.col="red";
	var tim=Date.now();
	while(1){
		if (wanderer.stack.length==0) {
			speed=getSpeed();
			/// used to be : dest.pos=getFarDest(wanderer.x,wanderer.y,wanderer.r);
		}else {
			dest.pos=wanderer.stack.pop();
		}
		upPath();
		while (wanderer.step > 0) {
			wanderer.step--;
			var dur=frameDur*1000-(Date.now()-tim);
			if (dur<1) {console.log(dur); dur=1; }
			await new Promise(g=>setTimeout(g,dur));
			tim=Date.now();

			var proj=[+Infinity,null];
			rounds.forEach(obstacle =>{
				if (obstacle==wanderer) return;
				/// * make obstacle immobile by substracting its speed to our speed
				/// * project obstacle's center on current traj
				/// * check if projection is ahead of us and not too far (between current pos and dest)
				let vec=dif(wanderer.vec,obstacle.vec);//wanderer.vec;//
				if (norm(vec)< 1e-9) return; //hardcoded
				let ret=dot_prod(dif(obstacle,wanderer),normed(vec))/norm(vec);
				if (ret<0 || ret> wanderer.step) return;
				if (obstacle.step!=null && ret>obstacle.step) return; 
				if (ret>proj[0]) return;
				///check if projection is inside collision circle (sum of both radii)
				let tmp=add(wanderer,mult(wanderer.vec,ret));
				let tmp2 = add(obstacle,mult(obstacle.vec,ret));
				if (dist(tmp2,tmp)>obstacle.r+wanderer.r) return;
				tmp=circle_collision.reject(
					{x:tmp2.x,y:tmp2.y,r:obstacle.r+wanderer.r+clearance}
					, tmp
				);
				proj=[ret, tmp];
			});
			if (proj[1]){
				proj=proj[1];
				wanderer.stack.push(dest.pos);
				dest.pos=proj;
				upPath();
			}

			wanderer.x+=wanderer.vec.x;
			wanderer.y+=wanderer.vec.y;
		} /// end while step is more than zero
		if (wanderer.stack.length==0) {
			// wanderer.vec=[0,0];
			rounds.remove(wanderer);
			return;
		}
	}
}

var curPair=[1,0];
curPair.next=function(){
	if( curPair[1]==curPair[0]-1) {
		if (curPair[0]>=rounds.length-1) {curPair[0]=1;curPair[1]=0;} else {curPair[0]++;curPair[1]=0; }
	} else curPair[1]++;
}
function handleCollisions(){ /// do not do rounds[i].upPath() on purpose so rounds dont stay stuck
	do{
		var a=rounds[curPair[0]], b=rounds[curPair[1]];
		if (a==null || b==null) break;
		if (a.immobile && b.immobile) break;
		if ( dist(a,b)>a.r+b.r) break 
		if (a.immobile || b.immobile) {
			if (b.immobile) {let tmp=b;b=a;a=tmp;}
			var tmp=circle_collision.reject({x:a.x,y:a.y,r:a.r+b.r},b);
			b.x=tmp.x; b.y=tmp.y;
			break;
		}
		var vec=normed(dif(b,a)); //TODO:move code to circle_collision{}
		var center=middle(b,a);
		var tmp=add(center,mult(vec,(a.r+b.r)/2));
		var tmp2=add(center,mult(vec,-(a.r+b.r)/2));
		b.x=tmp.x; b.y=tmp.y;
		a.x=tmp2.x; a.y=tmp2.y;
	}while(0);
	curPair.next();
}
	



/// Graphics

function drawCircle(x,y,r,col='white',fill=false) {
	ctx.beginPath();
	ctx.arc(x,y,r,0,2*pi);
	if (fill){
		ctx.fillStyle=col;ctx.fill();
	} else {
		ctx.strokeStyle=col;ctx.stroke();
	}
}

//bunch a hardcode, look away
function getcol(arg){
	if (arg<1) return getColorFast(0,1-arg); /// 0=red
	arg-=1;
	if (arg>5) { console.log("overstack", arg+1); }
	arg=Math.min(arg,5);
	return getColorFast(arg);
}

function draw() {
	// ctx.clearRect(0,0,cv.width,cv.height);
	ctx.fillStyle="#00000022";ctx.fillRect(0,0,cv.width,cv.height);
	rounds.forEach(rd =>{
		if (rd.type==null) {drawCircle(rd.x,rd.y,rd.r); return;}
		// var col=getcol(rd.stack.length).toColor();
		drawCircle(rd.x,rd.y,rd.r); //,col);
		ctx.textAlign    = 'center';
		ctx.textBaseline = 'middle'; 
		ctx.font = "20px Arial";ctx.fillStyle="gray";ctx.fillText(">v<^".substr(rd.type,1), rd.x, rd.y);
		// ctx.font = "10px Arial";ctx.fillStyle=col;ctx.fillText("x", rd.dest.pos.x, rd.dest.pos.y);
		// rd.stack.forEach(dt=>{ drawCircle(dt.x,dt.y,2,col); } );
	});
	// points.forEach(pt=>pt.pos &&  drawCircle(pt.pos.x, pt.pos.y, 2, pt.col));
	///Palette
	// for (let i=0;i<6;i++) {ctx.fillStyle= getColorFast(i).toColor();ctx.beginPath(); ctx.rect(0,i*20,25,20);ctx.fill();}
	requestAnimationFrame(draw);
}

/*** Start of Program ***/

draw();


rounds.push({r:100, x:w/2, y:h/2, vec:[0,0],immobile:true});


async function recurse(f,arg){ f(arg).then(()=>recurse(f,arg)); }
const NB_ROBOTS=12;
for (let i =0; i<NB_ROBOTS;++i) recurse(robot);

setInterval(() => {for (let i =0; i< rounds.length*(rounds.length-1)/2;++i)handleCollisions();}, 5);


</script>


</body>
</html>
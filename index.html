<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
Auto Round
</title>
<script src="geometry.js?1"></script>
<script src="libColor.js"></script>
</head>
<body style="margin:0px">
<canvas id="cv" width=600 height=500 style="background:black;border:solid 1px red; /*transform:scale(1,-1)*/"></canvas>
<script>

if (String(location).indexOf("jhepneige.github.io")>-1) document.title+=" online";

/// Augments
if (!Array.prototype.remove) Object.defineProperty(Array.prototype,"remove",{value(arg){ this.splice(this.indexOf(arg),1); }});
var flo=Math.floor, ran=Math.random, pi=Math.PI,sqrt=Math.sqrt;
var cos=Math.cos,sin=Math.sin;
function hexByte(x){return x.toString(16).padStart(2,"0") ;}

/// HMI
var cv=document.getElementById("cv");
var ctx=cv.getContext("2d");
var w=cv.width, h=cv.height;
document.getElementById("cv").addEventListener("mouseup", e=>{
	// draw();
	// getFarDest(obstacle.x,obstacle.y);
	shout();
});
function shout(msg="MOTHEATER") {
	var el=document.createElement("div");
	el.textContent=msg;
	el.style="position:relative;color:black";
	document.body.append(el);
	setTimeout(()=>{document.body.removeChild(el);}, 3000);
}


/// Resources

// var obstacle={r:50,x:175,y:200};
// var wanderer={r:20,x:35,y:30};

var rounds=[];
// var points=[];

/// Brain

//TODO: stuff hardcoded right and left
const frameDur=0.010; ///second
const clearance=0.1;
async function robot(){
	var side=flo( 4*ran() );

	var wanderer={
		r:15+10*ran()
		,x: (side & 1 ? w/2+(ran()-0.5)*250     : (side > 1 ? w-25 : 25 ) )
		,y: (side & 1 ? (side > 1 ? h-25 : 25 ) : h/2+(ran()-0.5)*200 )
		,vec:[0,0]
		,type:side
	};
	rounds.push(wanderer);
	var dest={pos:[
		 side & 1 ? wanderer.x              : (side > 1 ? 25 : w-25 )
		,side & 1 ? (side > 1 ? 25 : h-25 ) : wanderer.y
	]};
	var speed;
	wanderer.step=0;
	function getSpeed(){return 80*(1+0.5*ran()); } /// speed in pixel per second
	function upPath(){
		wanderer.vec=mult(normed(dif(dest.pos,wanderer)),frameDur*speed);
		wanderer.step=flo(dist(dest.pos,wanderer)/(frameDur*speed));
	}
	wanderer.stack=[];
	wanderer.dest=dest;
	// dest.col="red";
	// var detour={pos:null,col:"green"};
	// points.push(dest,detour);
	var tim=Date.now();
	while(1){
		if (wanderer.stack.length==0) {
			speed=getSpeed();
			//dest.pos=getFarDest(wanderer.x,wanderer.y,wanderer.r);
		}else {
			dest.pos=wanderer.stack.pop();
		}
		upPath();
		while (wanderer.step-- > 0) {
			var dur=frameDur*1000-(Date.now()-tim);
			if (dur<1) {console.log(dur); dur=1; }
			await new Promise(g=>setTimeout(g,dur));
			tim=Date.now();

			var proj=[9999,null];
			rounds.forEach(obstacle =>{
				if (obstacle==wanderer) return;
				///if round or its dest is inside obstacle: move dest out
				if ( circle_collision.isPointInside({x:obstacle.x,y:obstacle.y,r:obstacle.r+wanderer.r}, wanderer)) {
					let tmp=circle_collision.reject({x:obstacle.x,y:obstacle.y,r:obstacle.r+wanderer.r+clearance}, wanderer);
					wanderer.x=tmp.x; wanderer.y=tmp.y;
					upPath();
				}
				if ( circle_collision.isPointInside({x:obstacle.x,y:obstacle.y,r:obstacle.r+wanderer.r}, dest.pos)) {
					dest.pos=circle_collision.reject({x:obstacle.x,y:obstacle.y,r:obstacle.r+wanderer.r+clearance}, dest.pos);
					upPath();
				}
				/// * make obstacle immobile by substracting its speed to our speed
				/// * project obstacle's center on current traj
				/// * check if projection is ahead of us and not too far (between current pos and dest)
				let vec=dif(wanderer.vec,obstacle.vec);//wanderer.vec;//
				if (norm(vec)< 1e-9) return; //hardcoded
				let ret=dot_prod(dif(obstacle,wanderer),normed(vec))/norm(vec);
				if (ret<0 || ret> wanderer.step) return;
				if (obstacle.step!=null && ret>obstacle.step) return; 
				if (ret>proj[0]) return;
				///check if projection is inside collision circle (sum of both radii)
				let tmp=add(wanderer,mult(wanderer.vec,ret));
				let tmp2 = add(obstacle,mult(obstacle.vec,ret));
				if (dist(tmp2,tmp)>obstacle.r+wanderer.r) return;
				tmp=circle_collision.reject({x:tmp2.x,y:tmp2.y,r:obstacle.r+wanderer.r+clearance}, tmp);
				proj=[ret, tmp];
			});
			if (proj[1]){
				proj=proj[1];
				// detour.pos=proj;
				wanderer.stack.push(dest.pos);
				dest.pos=proj;
				upPath();
			}

			wanderer.x+=wanderer.vec.x;
			wanderer.y+=wanderer.vec.y;
		} /// end while step is more than zero
		if (wanderer.stack.length==0) {
			// wanderer.vec=[0,0];
			rounds.remove(wanderer);
			return;
		}
	}
}



/// Graphics

function drawCircle(x,y,r,col='white',fill=false) {
	ctx.beginPath();
	ctx.arc(x,y,r,0,2*pi);
	if (fill){
		ctx.fillStyle=col;ctx.fill();
	} else {
		ctx.strokeStyle=col;ctx.stroke();
	}
}

//bunch a hardcode, look away
function getcol(arg){
	if (arg<1) return getColorFast(0,1-arg); /// 0=red
	arg-=1;
	if (arg>5) { console.log("overstack", arg+1); }
	arg=Math.min(arg,5);
	return getColorFast(arg);
}

function draw() {
	// ctx.clearRect(0,0,cv.width,cv.height);
	ctx.fillStyle="#00000022";ctx.fillRect(0,0,cv.width,cv.height);
	rounds.forEach(rd =>{
		if (rd.type==null) {drawCircle(rd.x,rd.y,rd.r); return;}
		drawCircle(rd.x,rd.y,rd.r);//,getcol(rd.stack.length).toColor());
		ctx.textAlign    = 'center';
		ctx.textBaseline = 'middle'; 
		ctx.font = "20px Arial";ctx.fillStyle="red";ctx.fillText(">v<^".substr(rd.type,1), rd.x, rd.y);
		// ctx.font = "10px Arial";ctx.fillStyle="LightYellow";ctx.fillText("x", rd.dest.pos.x, rd.dest.pos.y);
		// rd.stack.forEach(dt=>{ drawCircle(dt.x,dt.y,2); } );
	});
	///Palette
	// for (let i=0;i<6;i++) {ctx.fillStyle= getColorFast(i).toColor();ctx.beginPath(); ctx.rect(0,i*20,25,20);ctx.fill();}
	requestAnimationFrame(draw);
}

draw();

// rounds.push({r:100, x:w/2, y:h/2, vec:[0,0]});


async function recurse(arg){ robot(arg).then(()=>recurse(arg)); }
const NB_ROBOTS=20;
for (let i =0; i<NB_ROBOTS;++i) recurse();




</script>


</body>
</html>
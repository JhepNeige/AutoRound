<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>
Auto Round
</title>
<script src="geometry.js"></script>
<script src="libColor.js"></script>
</head>
<body style="margin:0px">
<canvas id="cv" width=600 height=500 style="border:solid 1px red; /*transform:scale(1,-1)*/"></canvas>
<script>
/// Augments
var flo=Math.floor, ran=Math.random, pi=Math.PI,sqrt=Math.sqrt;
var cos=Math.cos,sin=Math.sin;

function hexByte(x){return x.toString(16).padStart(2,"0") ;}
if (!Array.prototype.toColor) Object.defineProperty(Array.prototype,"toColor",{value(){ return '#'+this.map(hexByte).join('') ; }});

/// HMI
var cv=document.getElementById("cv");
var ctx=cv.getContext("2d");
document.getElementById("cv").addEventListener("mouseup", e=>{
	obstacle.x=e.clientX;
	obstacle.y=e.clientY;
	// draw();
	// getFarDest(obstacle.x,obstacle.y);
});
function shout(msg="MOTHEATER") {
	var el=document.createElement("div");
	el.textContent=msg;
	el.style="position:relative;color:black";
	document.body.append(el);
	setTimeout(()=>{document.body.removeChild(el);}, 3000);
}


/// Resources

var obstacle={r:50,x:175,y:200};
var wanderer={r:20,x:35,y:30};
var rounds=[wanderer,obstacle];

/// Brain

const eps=1e-12;
function getFarDest(x,y) {
	var off=wanderer.r;
	var w=cv.width-off*2,h=cv.height-off*2;
	var r=h/2+(sqrt(w**2+h**2)/2-h/2)*ran();
	var tmp;
	var box=[off,off,off+w,off+h];
	var isec=circle_in_box.getIntersections(box, {x:x,y:y,r:r});
	if (isec.length<2) {tmp=2*pi*ran(); return [x+r*cos(tmp),y+r*sin(tmp)];}
	isec.forEach((p,i)=>{
		isec[i].t=Math.atan2(p.y-y,p.x-x);
	});
	isec.sort((a,b)=>a.t-b.t);
	tmp=[x+r*cos(isec[0].t+eps),y+r*sin(isec[0].t+eps)];
	if (tmp.x<box[0] ||tmp.x>box[2] ||tmp.y<box[1] ||tmp.y>box[3])
		isec.unshift(isec[isec.length-1]);
	else isec.push(isec[0]);
	var seg=[];
	for (let i=0;i<isec.length-1;i+=2) seg.push([isec[i],isec[i+1]]); //TODO: make a getSeg() in library instead
	tmp=seg[flo(seg.length*ran())];
	if (tmp[1].t<tmp[0].t)tmp[1].t+=2*pi;
	tmp=tmp[0].t+(tmp[1].t-tmp[0].t)*ran();
	tmp=[x+r*cos(tmp),y+r*sin(tmp)];
	return tmp;
}
var frameDur=0.025; ///second
var dest=[0,0];
var one=[0,0];
async function robot(){
	var speed,vec,step;
	var stack=[];
	function getSpeed(){return 200*(1+0.5*ran()); } /// speed in pixel per second
	function upPath(){ vec=mult(normed(dif(dest,wanderer)),frameDur*speed); step=flo(dist(dest,wanderer)/(frameDur*speed)); }
	var tim=Date.now();
	while(1){
		if (stack.length==0) {
			speed=getSpeed();
			dest=getFarDest(wanderer.x,wanderer.y);
		}else {
			dest=stack.pop();
		}
		upPath();
		while (step-- > 0) {
			var dur=frameDur*1000-(Date.now()-tim);
			if (dur<1) {console.log(dur); dur=1; }
			await new Promise(g=>setTimeout(g,dur));
			tim=Date.now();
			if ( circle_collision.isPointInside({x:obstacle.x,y:obstacle.y,r:obstacle.r+wanderer.r}, dest)) {
				dest=circle_collision.reject({x:obstacle.x,y:obstacle.y,r:obstacle.r+wanderer.r}, dest);
				upPath();
			}
			var tmp;
			tmp=dot_prod(dif(obstacle,wanderer),normed(vec));
			if (tmp>0 && tmp< dist(dest,wanderer) ) {
				tmp=point_of_line([wanderer,normed(vec)],tmp);
				if (dist(obstacle,tmp)<obstacle.r+wanderer.r) {
					one=tmp;
					stack.push(dest);
					dest=circle_collision.reject({x:obstacle.x,y:obstacle.y,r:obstacle.r+wanderer.r}, tmp);
					upPath();
				}
			}
			wanderer.x+=vec.x;
			wanderer.y+=vec.y;
		}
	}
}



/// Graphics

function drawCircle(x,y,r,col='black',fill=false) {
	ctx.beginPath();
	ctx.arc(x,y,r,0,2*pi);
	if (fill){
		ctx.fillStyle=col;ctx.fill();
	} else {
		ctx.strokeStyle=col;ctx.stroke();
	}
}

function draw() {
	setTimeout(draw, 20);
	//ctx.clearRect(0,0,cv.width,cv.height);
	ctx.fillStyle="#ffffff11";
	ctx.beginPath(); ctx.rect(0,0,cv.width,cv.height); ctx.fill();
	drawCircle(obstacle.x,obstacle.y,obstacle.r);
	drawCircle(wanderer.x,wanderer.y,wanderer.r);
	
	// rounds.forEach(rd =>{
		// let pos=[cv.width/2+rd.x-rounds[1].x,cv.height/2+rd.y-rounds[1].y];
		// drawCircle(pos.x,pos.y,rd.r,"blue");
	// });
	
	drawCircle(dest.x,dest.y,3,"red",true);
	drawCircle(one.x,one.y,3,"green",true);
	///Palette
	///for (let i=0;i<6;i++) {ctx.fillStyle= getColorFast(i).toColor();ctx.beginPath(); ctx.rect(0,i*20,25,20);ctx.fill();}

}

draw();
robot();





</script>


</body>
</html>